/*
 * The Jira Cloud platform REST API
 *
 * Jira Cloud platform REST API documentation
 *
 * The version of the OpenAPI document: 1001.0.0-SNAPSHOT-ccbf72d894d6b699175624f7a94244e68c9dbc6d
 * Contact: ecosystem@atlassian.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`addon_properties_resource_period_delete_addon_property_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddonPropertiesResourcePeriodDeleteAddonPropertyDeleteError {
    Status400(models::OperationMessage),
    Status401(models::OperationMessage),
    Status404(models::OperationMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`addon_properties_resource_period_get_addon_properties_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddonPropertiesResourcePeriodGetAddonPropertiesGetError {
    Status401(models::OperationMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`addon_properties_resource_period_get_addon_property_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddonPropertiesResourcePeriodGetAddonPropertyGetError {
    Status400(models::OperationMessage),
    Status401(models::OperationMessage),
    Status404(models::OperationMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`addon_properties_resource_period_put_addon_property_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddonPropertiesResourcePeriodPutAddonPropertyPutError {
    Status400(models::OperationMessage),
    Status401(models::OperationMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_forge_app_property`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteForgeAppPropertyError {
    Status400(models::OperationMessage),
    Status401(),
    Status403(),
    Status404(models::OperationMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`put_forge_app_property`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PutForgeAppPropertyError {
    Status400(models::OperationMessage),
    Status401(),
    Status403(),
    UnknownValue(serde_json::Value),
}


/// Deletes an app's property.  **[Permissions](#permissions) required:** Only a Connect app whose key matches `addonKey` can make this request. Additionally, Forge apps can access Connect app properties (stored against the same `app.connect.key`).
pub async fn addon_properties_resource_period_delete_addon_property_delete(configuration: &configuration::Configuration, addon_key: &str, property_key: &str) -> Result<(), Error<AddonPropertiesResourcePeriodDeleteAddonPropertyDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_addon_key = addon_key;
    let p_property_key = property_key;

    let uri_str = format!("{}/rest/atlassian-connect/1/addons/{addonKey}/properties/{propertyKey}", configuration.base_path, addonKey=crate::apis::urlencode(p_addon_key), propertyKey=crate::apis::urlencode(p_property_key));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AddonPropertiesResourcePeriodDeleteAddonPropertyDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets all the properties of an app.  **[Permissions](#permissions) required:** Only a Connect app whose key matches `addonKey` can make this request. Additionally, Forge apps can access Connect app properties (stored against the same `app.connect.key`).
pub async fn addon_properties_resource_period_get_addon_properties_get(configuration: &configuration::Configuration, addon_key: &str) -> Result<models::PropertyKeys, Error<AddonPropertiesResourcePeriodGetAddonPropertiesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_addon_key = addon_key;

    let uri_str = format!("{}/rest/atlassian-connect/1/addons/{addonKey}/properties", configuration.base_path, addonKey=crate::apis::urlencode(p_addon_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PropertyKeys`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PropertyKeys`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddonPropertiesResourcePeriodGetAddonPropertiesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the key and value of an app's property.  **[Permissions](#permissions) required:** Only a Connect app whose key matches `addonKey` can make this request. Additionally, Forge apps can access Connect app properties (stored against the same `app.connect.key`).
pub async fn addon_properties_resource_period_get_addon_property_get(configuration: &configuration::Configuration, addon_key: &str, property_key: &str) -> Result<models::EntityProperty, Error<AddonPropertiesResourcePeriodGetAddonPropertyGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_addon_key = addon_key;
    let p_property_key = property_key;

    let uri_str = format!("{}/rest/atlassian-connect/1/addons/{addonKey}/properties/{propertyKey}", configuration.base_path, addonKey=crate::apis::urlencode(p_addon_key), propertyKey=crate::apis::urlencode(p_property_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EntityProperty`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EntityProperty`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddonPropertiesResourcePeriodGetAddonPropertyGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Sets the value of an app's property. Use this resource to store custom data for your app.  The value of the request body must be a [valid](http://tools.ietf.org/html/rfc4627), non-empty JSON blob. The maximum length is 32768 characters.  **[Permissions](#permissions) required:** Only a Connect app whose key matches `addonKey` can make this request. Additionally, Forge apps can access Connect app properties (stored against the same `app.connect.key`).
pub async fn addon_properties_resource_period_put_addon_property_put(configuration: &configuration::Configuration, addon_key: &str, property_key: &str, body: Option<serde_json::Value>) -> Result<models::OperationMessage, Error<AddonPropertiesResourcePeriodPutAddonPropertyPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_addon_key = addon_key;
    let p_property_key = property_key;
    let p_body = body;

    let uri_str = format!("{}/rest/atlassian-connect/1/addons/{addonKey}/properties/{propertyKey}", configuration.base_path, addonKey=crate::apis::urlencode(p_addon_key), propertyKey=crate::apis::urlencode(p_property_key));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OperationMessage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OperationMessage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddonPropertiesResourcePeriodPutAddonPropertyPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deletes a Forge app's property.  **[Permissions](#permissions) required:** Only Forge apps can make this request.  The new `write:app-data:jira` OAuth scope is 100% optional now, and not using it won't break your app. However, we recommend adding it to your app's scope list because we will eventually make it mandatory.
pub async fn delete_forge_app_property(configuration: &configuration::Configuration, property_key: &str) -> Result<(), Error<DeleteForgeAppPropertyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_property_key = property_key;

    let uri_str = format!("{}/rest/forge/1/app/properties/{propertyKey}", configuration.base_path, propertyKey=crate::apis::urlencode(p_property_key));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteForgeAppPropertyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Sets the value of a Forge app's property. These values can be retrieved in [Jira expressions](/cloud/jira/platform/jira-expressions/) through the `app` [context variable](/cloud/jira/platform/jira-expressions/#context-variables). They are also available in [entity property display conditions](/platform/forge/manifest-reference/display-conditions/entity-property-conditions/).  For other use cases, use the [Storage API](/platform/forge/runtime-reference/storage-api/).  The value of the request body must be a [valid](http://tools.ietf.org/html/rfc4627), non-empty JSON blob. The maximum length is 32768 characters.  **[Permissions](#permissions) required:** Only Forge apps can make this request.  The new `write:app-data:jira` OAuth scope is 100% optional now, and not using it won't break your app. However, we recommend adding it to your app's scope list because we will eventually make it mandatory.
pub async fn put_forge_app_property(configuration: &configuration::Configuration, property_key: &str, body: Option<serde_json::Value>) -> Result<models::OperationMessage, Error<PutForgeAppPropertyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_property_key = property_key;
    let p_body = body;

    let uri_str = format!("{}/rest/forge/1/app/properties/{propertyKey}", configuration.base_path, propertyKey=crate::apis::urlencode(p_property_key));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    req_builder = req_builder.json(&p_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OperationMessage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OperationMessage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PutForgeAppPropertyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

